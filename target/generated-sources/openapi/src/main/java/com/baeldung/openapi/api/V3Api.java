/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (7.8.0).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.baeldung.openapi.api;

import com.baeldung.openapi.model.ApproveTransportDocumentRequest;
import com.baeldung.openapi.model.CreateShippingInstructions;
import com.baeldung.openapi.model.ErrorResponse;
import com.baeldung.openapi.model.PatchShippingInstructionsRequest;
import com.baeldung.openapi.model.ShippingInstructions;
import com.baeldung.openapi.model.ShippingInstructionsNotification;
import com.baeldung.openapi.model.ShippingInstructionsResponse;
import com.baeldung.openapi.model.TransportDocument;
import com.baeldung.openapi.model.TransportDocumentNotification;
import com.baeldung.openapi.model.UpdateShippingInstructions;
import io.swagger.v3.oas.annotations.ExternalDocumentation;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.util.List;
import java.util.Map;
import javax.annotation.Generated;

@Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2024-09-30T15:24:55.896324973+02:00[Europe/Paris]", comments = "Generator version: 7.8.0")
@Validated
@Tag(name = "Transport Document", description = "The Transport Document endPoints to be implemented by **providers** of the Bill of Lading API ")
public interface V3Api {

    default V3ApiDelegate getDelegate() {
        return new V3ApiDelegate() {};
    }

    /**
     * PATCH /v3/transport-documents/{transportDocumentReference} : Approve a Transport Document 
     * A way for the consumer to Approve the &#x60;Draft Transport Document&#x60;. This endPoint corresponds with **UseCase 7 - Approve Draft Transport Document**.  ## Precondition In order to approve a &#x60;Draft Transport Document&#x60;, the status of the &#x60;Transport Document&#x60; needs to be in status &#x60;DRAFT&#x60;  ## Postcondition The provider has received an approval from the consumer for a &#x60;Transport Document&#x60; that is in state &#x60;DRAFT&#x60;.  The consumer will receive a &#x60;202&#x60; (Accepted) if the payload schema-validates or a &#x60;400&#x60; (Bad Request) if it does not.  ## Flow for the &#x60;202&#x60; (Accepted) response The following occurs when a provider receives an approval: 1. The payload is schema-validated. In case the payload **is invalid** a &#x60;400&#x60; (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided.     - all values provided have correct data type. 3. An empty response is returned and the consumer now awaits further processing by the provider.  Once processed, the &#x60;Transport Document&#x60; is &#x60;ISSUED&#x60; and a [Transport Document Notification](#/TransportDocumentNotification) is sent. In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/transport-documents/{transportDocumentReference}      endPoint to check if the &#x60;transportDocumentStatus&#x60; of the &#x60;Transport Document&#x60; has changed. 
     *
     * @param transportDocumentReference The &#x60;transportDocumentReference&#x60; of the &#x60;Transport Document&#x60;  (required)
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @param approveTransportDocumentRequest  (optional)
     * @return The approval of the &#x60;Transport Document&#x60; has been accepted and now awaits further processing  (status code 202)
     *         or In case the Approve payload does not schema validate a &#x60;400&#x60; (Bad Request) is returned  (status code 400)
     *         or In case the consumer is requesting a &#x60;transportDocumentReference&#x60; that does not exist.  (status code 404)
     *         or In case the consumer is requesting a &#x60;transportDocumentReference&#x60; that is being processed it is possible to return a &#x60;409&#x60; (Conflict).  (status code 409)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "approveTransportDocument",
        summary = "Approve a Transport Document ",
        description = "A way for the consumer to Approve the `Draft Transport Document`. This endPoint corresponds with **UseCase 7 - Approve Draft Transport Document**.  ## Precondition In order to approve a `Draft Transport Document`, the status of the `Transport Document` needs to be in status `DRAFT`  ## Postcondition The provider has received an approval from the consumer for a `Transport Document` that is in state `DRAFT`.  The consumer will receive a `202` (Accepted) if the payload schema-validates or a `400` (Bad Request) if it does not.  ## Flow for the `202` (Accepted) response The following occurs when a provider receives an approval: 1. The payload is schema-validated. In case the payload **is invalid** a `400` (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided.     - all values provided have correct data type. 3. An empty response is returned and the consumer now awaits further processing by the provider.  Once processed, the `Transport Document` is `ISSUED` and a [Transport Document Notification](#/TransportDocumentNotification) is sent. In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/transport-documents/{transportDocumentReference}      endPoint to check if the `transportDocumentStatus` of the `Transport Document` has changed. ",
        tags = { "Transport Document" },
        responses = {
            @ApiResponse(responseCode = "202", description = "The approval of the `Transport Document` has been accepted and now awaits further processing "),
            @ApiResponse(responseCode = "400", description = "In case the Approve payload does not schema validate a `400` (Bad Request) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "In case the consumer is requesting a `transportDocumentReference` that does not exist. ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "409", description = "In case the consumer is requesting a `transportDocumentReference` that is being processed it is possible to return a `409` (Conflict). ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PATCH,
        value = "/v3/transport-documents/{transportDocumentReference}",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<Void> approveTransportDocument(
        @Pattern(regexp = "^\\S(?:.*\\S)?$") @Size(max = 20) @Parameter(name = "transportDocumentReference", description = "The `transportDocumentReference` of the `Transport Document` ", required = true, in = ParameterIn.PATH) @PathVariable("transportDocumentReference") String transportDocumentReference,
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion,
        @Parameter(name = "ApproveTransportDocumentRequest", description = "") @Valid @RequestBody(required = false) ApproveTransportDocumentRequest approveTransportDocumentRequest
    ) {
        return getDelegate().approveTransportDocument(transportDocumentReference, apIVersion, approveTransportDocumentRequest);
    }


    /**
     * POST /v3/shipping-instructions : Creates a Shipping Instructions 
     * Creates a new &#x60;Shipping Instructions&#x60;. This endPoint corresponds with **UseCase 1 - Submit Shipping Instructions**.  ## Precondition The consumer has information for a &#x60;Shipping Instructions&#x60;. The empty equipment has been released to the shipper. The &#x60;Booking&#x60; is in state &#x60;CONFIRMED&#x60;.  ## Postcondition The provider has received the &#x60;Shipping Instructions&#x60;.  The consumer will receive a &#x60;202&#x60; (Accepted) if the payload schema validates or a &#x60;400&#x60; (Bad Request) if it does not.  ## Flow for the &#x60;202&#x60; (Accepted) response The following occurs when a provider receives a &#x60;Shipping Instructions&#x60;: 1. The payload (&#x60;Shipping Instructions&#x60;) is schema-validated. In case the payload **is invalid** a &#x60;400&#x60; (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided.     - all values provided have correct data type.     A &#x60;shippingInstructionsReference&#x60; (as a reference to the &#x60;Shipping Instructions&#x60;) is created and linked to the payload in the provider system.       **For the rest of this description and in all examples the value &#x60;si-123&#x60; will be used as &#x60;shippingInstructionsReference&#x60;**  3. A &#x60;202&#x60; (Accepted) response is returned with a payload containing **only** the &#x60;shippingInstructionsReference&#x60;:     &#x60;&#x60;&#x60;     {       shippingInstructionsReference: &#39;si-123&#39;     }     &#x60;&#x60;&#x60;  For &#x60;POST&#x60; &#x60;Shipping Instructions&#x60; the process ends here. The &#x60;Shipping Instructions&#x60;:   - is now accepted by the provider system   - the &#x60;Shipping Instructions&#x60; does not yet have any status and cannot be queried (no &#x60;GET&#x60; request is possible until the &#x60;Shipping Instructions&#x60; is further processed in the provider system)   - a &#x60;202&#x60; (Accepted) response is sent to the consumer with a payload **only** containing the &#x60;shippingInstructionsReference&#x60;   - awaits further processing by the provider  The provider will now start asynchronous processing. Once processed, the  status &#x60;RECEIVED&#x60; of the &#x60;Shipping Instructions&#x60; will be communicated via a [Shipping Instructions Notification](#/ShippingInstructionsNotification). In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/shipping-instructions/{documentReference}        endPoint to check if the &#x60;shippingInstructionsStatus&#x60; of the &#x60;Shipping Instructions&#x60; has changed.      After the status has changed to &#x60;RECEIVED&#x60; further processing can continue by provider and will be communicated via a [Shipping Instructions Notification](#/ShippingInstructionsNotification). 
     *
     * @param createShippingInstructions Parameters used to create the &#x60;Shipping Instructions&#x60;  (required)
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @return The &#x60;Shipping Instructions&#x60; has been accepted by the provider. The &#x60;Shipping Instructions&#x60; does not yet have a &#x60;shippingInstructionsStatus&#x60; - it is not possible to call the &#x60;GET&#x60; endPoint until the &#x60;Shipping Instructions&#x60; is further processed in provider system. The consumer is now awaiting provider to process the &#x60;Shipping Instructions&#x60; asynchronously.  (status code 202)
     *         or In case the &#x60;Shipping Instructions&#x60; does not schema validate a &#x60;400&#x60; (Bad Request) is returned  (status code 400)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "createShippingInstructions",
        summary = "Creates a Shipping Instructions ",
        description = "Creates a new `Shipping Instructions`. This endPoint corresponds with **UseCase 1 - Submit Shipping Instructions**.  ## Precondition The consumer has information for a `Shipping Instructions`. The empty equipment has been released to the shipper. The `Booking` is in state `CONFIRMED`.  ## Postcondition The provider has received the `Shipping Instructions`.  The consumer will receive a `202` (Accepted) if the payload schema validates or a `400` (Bad Request) if it does not.  ## Flow for the `202` (Accepted) response The following occurs when a provider receives a `Shipping Instructions`: 1. The payload (`Shipping Instructions`) is schema-validated. In case the payload **is invalid** a `400` (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided.     - all values provided have correct data type.     A `shippingInstructionsReference` (as a reference to the `Shipping Instructions`) is created and linked to the payload in the provider system.       **For the rest of this description and in all examples the value `si-123` will be used as `shippingInstructionsReference`**  3. A `202` (Accepted) response is returned with a payload containing **only** the `shippingInstructionsReference`:     ```     {       shippingInstructionsReference: 'si-123'     }     ```  For `POST` `Shipping Instructions` the process ends here. The `Shipping Instructions`:   - is now accepted by the provider system   - the `Shipping Instructions` does not yet have any status and cannot be queried (no `GET` request is possible until the `Shipping Instructions` is further processed in the provider system)   - a `202` (Accepted) response is sent to the consumer with a payload **only** containing the `shippingInstructionsReference`   - awaits further processing by the provider  The provider will now start asynchronous processing. Once processed, the  status `RECEIVED` of the `Shipping Instructions` will be communicated via a [Shipping Instructions Notification](#/ShippingInstructionsNotification). In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/shipping-instructions/{documentReference}        endPoint to check if the `shippingInstructionsStatus` of the `Shipping Instructions` has changed.      After the status has changed to `RECEIVED` further processing can continue by provider and will be communicated via a [Shipping Instructions Notification](#/ShippingInstructionsNotification). ",
        tags = { "Shipping Instructions" },
        responses = {
            @ApiResponse(responseCode = "202", description = "The `Shipping Instructions` has been accepted by the provider. The `Shipping Instructions` does not yet have a `shippingInstructionsStatus` - it is not possible to call the `GET` endPoint until the `Shipping Instructions` is further processed in provider system. The consumer is now awaiting provider to process the `Shipping Instructions` asynchronously. ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ShippingInstructionsResponse.class))
            }),
            @ApiResponse(responseCode = "400", description = "In case the `Shipping Instructions` does not schema validate a `400` (Bad Request) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v3/shipping-instructions",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<ShippingInstructionsResponse> createShippingInstructions(
        @Parameter(name = "CreateShippingInstructions", description = "Parameters used to create the `Shipping Instructions` ", required = true) @Valid @RequestBody CreateShippingInstructions createShippingInstructions,
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion
    ) {
        return getDelegate().createShippingInstructions(createShippingInstructions, apIVersion);
    }


    /**
     * GET /v3/shipping-instructions/{documentReference} : Gets the Shipping Instructions 
     * Retrieves the &#x60;Shipping Instructions&#x60; with the &#x60;documentReference&#x60;. The path can contain a &#x60;shippingInstructionsReference&#x60; or a &#x60;transportDocumentReference&#x60;. It is recommended to use this endPoint to &#x60;GET&#x60; data before an update is made to make sure latest version is being updated.  The default payload when calling this endPoint is the \&quot;original\&quot; &#x60;Shipping Instructions&#x60;. It is also possible to get the latest update to a &#x60;Shipping Instructions&#x60; called the &#x60;Updated Shipping Instructions&#x60;. In order to get the &#x60;Update Shipping Instructions&#x60;, it is necessary to use the query parameter &#x60;updatedContent&#x60; and set it to &#x60;true&#x60;.      GET /v3/shipping-instructions/{documentReference}?updatedContent&#x3D;true  The &#x60;status&#x60; of the \&quot;original\&quot; &#x60;Shipping Instructions&#x60; is included in both payloads as &#x60;shippingInstructionsStatus&#x60;. &#x60;updatedShippingInstructionsStatus&#x60; and related content is only available after a consumer has requested an update via **UseCase 3: Submit updated Shipping Instructions** and until: - the provider requests for a new update (**UseCase 2: Request to update Shipping Instructions**) in which case the \&quot;old update\&quot; is no longer accessible. - the consumer submits a new update (**UseCase 3: Submit updated Shipping Instructions**) in which case the \&quot;new update\&quot; provided **replaces** the \&quot;old update\&quot;.  If &#x60;updatedContent&#x3D;true&#x60; is requested but no update has yet been provided by the consumer **or** the state of the \&quot;original\&quot; &#x60;Shipping Instructions&#x60; is &#x60;PENDING_UPDATE&#x60;, then a &#x60;404&#x60; (Not Found) is returned.  If the provider is requesting changes to the &#x60;Shipping Instructions&#x60;, the &#x60;Feedback&#x60; object is used to inform the consumer what needs to change.  In case no subscription (&#x60;Notification&#x60;) has been set up - it is possible to use this endPoint to poll on in order to detect if &#x60;shippingInstructionsStatus&#x60; and/or &#x60;updatedShippingInstructionsStatus&#x60; has changed.  In case a previous request is being processed by the provider - a &#x60;202&#x60; (Accepted) with **no payload** can be used as a response until the processing is finished. 
     *
     * @param documentReference An identifier for a &#x60;Shipping Instructions&#x60;. It can either be a &#x60;shippingInstructionsReference&#x60; or a &#x60;transportDocumentReference&#x60;.  (required)
     * @param updatedContent If set to &#x60;true&#x60;, the payload returned is the content of the &#x60;Updated Shipping Instructions&#x60;.  Default value is &#x60;false&#x60; in which case the content of the \&quot;original\&quot; &#x60;Shipping Instructions&#x60; is returned.  **Condition:** Can only be used if an update has been made by the consumer (via **UseCase 3: Submit updated Shipping Instructions**) and **until** a new updated is requested by the provider. If no updates have been made a &#x60;404&#x60; (Not Found) response will be returned  (optional, default to false)
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @return Fetching the content of either the \&quot;original\&quot; &#x60;Shipping Instructions&#x60; or the &#x60;Updated Shipping Instructions&#x60;  (status code 200)
     *         or The &#x60;Shipping Instructions&#x60; is currently being processed by the provider. No payload is returned. A new &#x60;GET&#x60; request has to be made periodically to check if the provider has finished processing the &#x60;Shipping Instructions&#x60;.  (status code 202)
     *         or In case the consumer is requesting the content of the &#x60;UpdatedShipping Instructions&#x60;, and no update has yet been requested.  A &#x60;404&#x60; (Not Found) can also be sent in case the provider does not know of the &#x60;documentReference&#x60; used in the request (the resource does not exist)  (status code 404)
     *         or In case the provider is processing the &#x60;Shipping Instructions&#x60; - it is possible for the provider to reject new incoming requests by returning a &#x60;409&#x60; (Conflict)  (status code 409)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "getShippingInstructions",
        summary = "Gets the Shipping Instructions ",
        description = "Retrieves the `Shipping Instructions` with the `documentReference`. The path can contain a `shippingInstructionsReference` or a `transportDocumentReference`. It is recommended to use this endPoint to `GET` data before an update is made to make sure latest version is being updated.  The default payload when calling this endPoint is the \"original\" `Shipping Instructions`. It is also possible to get the latest update to a `Shipping Instructions` called the `Updated Shipping Instructions`. In order to get the `Update Shipping Instructions`, it is necessary to use the query parameter `updatedContent` and set it to `true`.      GET /v3/shipping-instructions/{documentReference}?updatedContent=true  The `status` of the \"original\" `Shipping Instructions` is included in both payloads as `shippingInstructionsStatus`. `updatedShippingInstructionsStatus` and related content is only available after a consumer has requested an update via **UseCase 3: Submit updated Shipping Instructions** and until: - the provider requests for a new update (**UseCase 2: Request to update Shipping Instructions**) in which case the \"old update\" is no longer accessible. - the consumer submits a new update (**UseCase 3: Submit updated Shipping Instructions**) in which case the \"new update\" provided **replaces** the \"old update\".  If `updatedContent=true` is requested but no update has yet been provided by the consumer **or** the state of the \"original\" `Shipping Instructions` is `PENDING_UPDATE`, then a `404` (Not Found) is returned.  If the provider is requesting changes to the `Shipping Instructions`, the `Feedback` object is used to inform the consumer what needs to change.  In case no subscription (`Notification`) has been set up - it is possible to use this endPoint to poll on in order to detect if `shippingInstructionsStatus` and/or `updatedShippingInstructionsStatus` has changed.  In case a previous request is being processed by the provider - a `202` (Accepted) with **no payload** can be used as a response until the processing is finished. ",
        tags = { "Shipping Instructions" },
        responses = {
            @ApiResponse(responseCode = "200", description = "Fetching the content of either the \"original\" `Shipping Instructions` or the `Updated Shipping Instructions` ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ShippingInstructions.class))
            }),
            @ApiResponse(responseCode = "202", description = "The `Shipping Instructions` is currently being processed by the provider. No payload is returned. A new `GET` request has to be made periodically to check if the provider has finished processing the `Shipping Instructions`. "),
            @ApiResponse(responseCode = "404", description = "In case the consumer is requesting the content of the `UpdatedShipping Instructions`, and no update has yet been requested.  A `404` (Not Found) can also be sent in case the provider does not know of the `documentReference` used in the request (the resource does not exist) ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "409", description = "In case the provider is processing the `Shipping Instructions` - it is possible for the provider to reject new incoming requests by returning a `409` (Conflict) ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/v3/shipping-instructions/{documentReference}",
        produces = { "application/json" }
    )
    
    default ResponseEntity<ShippingInstructions> getShippingInstructions(
        @Pattern(regexp = "^\\S(?:.*\\S)?$") @Size(max = 100) @Parameter(name = "documentReference", description = "An identifier for a `Shipping Instructions`. It can either be a `shippingInstructionsReference` or a `transportDocumentReference`. ", required = true, in = ParameterIn.PATH) @PathVariable("documentReference") String documentReference,
        @Parameter(name = "updatedContent", description = "If set to `true`, the payload returned is the content of the `Updated Shipping Instructions`.  Default value is `false` in which case the content of the \"original\" `Shipping Instructions` is returned.  **Condition:** Can only be used if an update has been made by the consumer (via **UseCase 3: Submit updated Shipping Instructions**) and **until** a new updated is requested by the provider. If no updates have been made a `404` (Not Found) response will be returned ", in = ParameterIn.QUERY) @Valid @RequestParam(value = "updatedContent", required = false, defaultValue = "false") Boolean updatedContent,
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion
    ) {
        return getDelegate().getShippingInstructions(documentReference, updatedContent, apIVersion);
    }


    /**
     * GET /v3/transport-documents/{transportDocumentReference} : Gets the Transport Document 
     * Retrieves the &#x60;Transport Document&#x60; with the &#x60;transportDocumentReference&#x60; in the path. 
     *
     * @param transportDocumentReference The &#x60;transportDocumentReference&#x60; of the &#x60;Transport Document&#x60;  (required)
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @return The &#x60;Transport Document&#x60;  (status code 200)
     *         or The &#x60;Transport Document&#x60; is currently being processed by the provider. No payload is returned. A new &#x60;GET&#x60; request has to be made periodically to check if the provider has finished processing the &#x60;Transport Document&#x60;.  (status code 202)
     *         or In case the consumer is requesting a &#x60;transportDocumentReference&#x60; that does not exist.  (status code 404)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "getTransportDocument",
        summary = "Gets the Transport Document ",
        description = "Retrieves the `Transport Document` with the `transportDocumentReference` in the path. ",
        tags = { "Transport Document" },
        responses = {
            @ApiResponse(responseCode = "200", description = "The `Transport Document` ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = TransportDocument.class))
            }),
            @ApiResponse(responseCode = "202", description = "The `Transport Document` is currently being processed by the provider. No payload is returned. A new `GET` request has to be made periodically to check if the provider has finished processing the `Transport Document`. "),
            @ApiResponse(responseCode = "404", description = "In case the consumer is requesting a `transportDocumentReference` that does not exist. ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/v3/transport-documents/{transportDocumentReference}",
        produces = { "application/json" }
    )
    
    default ResponseEntity<TransportDocument> getTransportDocument(
        @Pattern(regexp = "^\\S(?:.*\\S)?$") @Size(max = 20) @Parameter(name = "transportDocumentReference", description = "The `transportDocumentReference` of the `Transport Document` ", required = true, in = ParameterIn.PATH) @PathVariable("transportDocumentReference") String transportDocumentReference,
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion
    ) {
        return getDelegate().getTransportDocument(transportDocumentReference, apIVersion);
    }


    /**
     * PATCH /v3/shipping-instructions/{documentReference} : Cancels an update to a Shipping Instructions 
     * A way for the consumer to Cancel an &#x60;Updated Shipping Instructions&#x60;. This endPoint corresponds with **UseCase 5 - Cancel update to Shipping Instructions**.  ## Precondition In order to cancel an &#x60;Updated Shipping Instructions&#x60;, the status of the &#x60;Updated Shipping Instructions&#x60; must be in in status &#x60;UPDATE_RECEIVED&#x60;. The status of the &#x60;Shipping Instructions&#x60; can be either &#x60;RECEIVED&#x60; or &#x60;PENDING_UPDATE&#x60;.  ## Postcondition The provider has received a cancellation from the consumer for an &#x60;Updated Shipping Instructions&#x60; that is in state &#x60;UPDATE_RECEIVED&#x60;.  The consumer will receive a &#x60;202&#x60; (Accepted) if the payload schema-validates or a &#x60;400&#x60; (Bad Request) if it does not.  ## Flow for the &#x60;202&#x60; (Accepted) response The following occurs when a provider receives a cancellation: 1. The payload is schema-validated. In case the payload **is invalid** a &#x60;400&#x60; (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided.     - all values provided have correct data type. 3. An empty response is returned and the consumer now awaits further processing by the provider.  Once processed, the &#x60;Updated Shipping Instructions&#x60; is cancelled and a [Shipping Instructions Notification](#/ShippingInstructionsNotification) will be sent. In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/shipping-instructions/{documentReference}      endPoint to check if the &#x60;shippingInstructionsStatus&#x60; and &#x60;updatedShippingInstructionsStatus&#x60; of the &#x60;Shipping Instructions&#x60; has changed. 
     *
     * @param documentReference An identifier for a &#x60;Shipping Instructions&#x60;. It can either be a &#x60;shippingInstructionsReference&#x60; or a &#x60;transportDocumentReference&#x60;.  (required)
     * @param patchShippingInstructionsRequest Cancel the &#x60;Update Shipping Instructions&#x60;  (required)
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @return The cancellation of the &#x60;Updated Shipping Instructions&#x60; is accepted and is now awaiting further processing by the provider.  (status code 202)
     *         or In case the cancel payload does not schema validate a &#x60;400&#x60; (Bad Request) is returned  (status code 400)
     *         or In case the consumer is trying to cancel a &#x60;Shipping Instructions&#x60; that does not have an ongoing update request, an &#x60;Updated Shipping Instructions&#x60; that is in state &#x60;UPDATE_RECEIVED&#x60;.  A &#x60;404&#x60; (Not Found) can also be sent in case the provider does not know of the &#x60;documentReference&#x60; used in the request (the resource does not exist)  (status code 404)
     *         or In case the provider is already processing the &#x60;Updated Shipping Instructions&#x60; matching &#x60;shippingInstructionsReference&#x3D;&#39;si-123&#39;&#x60; it is possible to reject the &#x60;PATCH&#x60; request with a &#x60;409&#x60; (Conflict) response  (status code 409)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "patchShippingInstructions",
        summary = "Cancels an update to a Shipping Instructions ",
        description = "A way for the consumer to Cancel an `Updated Shipping Instructions`. This endPoint corresponds with **UseCase 5 - Cancel update to Shipping Instructions**.  ## Precondition In order to cancel an `Updated Shipping Instructions`, the status of the `Updated Shipping Instructions` must be in in status `UPDATE_RECEIVED`. The status of the `Shipping Instructions` can be either `RECEIVED` or `PENDING_UPDATE`.  ## Postcondition The provider has received a cancellation from the consumer for an `Updated Shipping Instructions` that is in state `UPDATE_RECEIVED`.  The consumer will receive a `202` (Accepted) if the payload schema-validates or a `400` (Bad Request) if it does not.  ## Flow for the `202` (Accepted) response The following occurs when a provider receives a cancellation: 1. The payload is schema-validated. In case the payload **is invalid** a `400` (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided.     - all values provided have correct data type. 3. An empty response is returned and the consumer now awaits further processing by the provider.  Once processed, the `Updated Shipping Instructions` is cancelled and a [Shipping Instructions Notification](#/ShippingInstructionsNotification) will be sent. In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/shipping-instructions/{documentReference}      endPoint to check if the `shippingInstructionsStatus` and `updatedShippingInstructionsStatus` of the `Shipping Instructions` has changed. ",
        tags = { "Shipping Instructions" },
        responses = {
            @ApiResponse(responseCode = "202", description = "The cancellation of the `Updated Shipping Instructions` is accepted and is now awaiting further processing by the provider. "),
            @ApiResponse(responseCode = "400", description = "In case the cancel payload does not schema validate a `400` (Bad Request) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "In case the consumer is trying to cancel a `Shipping Instructions` that does not have an ongoing update request, an `Updated Shipping Instructions` that is in state `UPDATE_RECEIVED`.  A `404` (Not Found) can also be sent in case the provider does not know of the `documentReference` used in the request (the resource does not exist) ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "409", description = "In case the provider is already processing the `Updated Shipping Instructions` matching `shippingInstructionsReference='si-123'` it is possible to reject the `PATCH` request with a `409` (Conflict) response ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PATCH,
        value = "/v3/shipping-instructions/{documentReference}",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<Void> patchShippingInstructions(
        @Pattern(regexp = "^\\S(?:.*\\S)?$") @Size(max = 100) @Parameter(name = "documentReference", description = "An identifier for a `Shipping Instructions`. It can either be a `shippingInstructionsReference` or a `transportDocumentReference`. ", required = true, in = ParameterIn.PATH) @PathVariable("documentReference") String documentReference,
        @Parameter(name = "PatchShippingInstructionsRequest", description = "Cancel the `Update Shipping Instructions` ", required = true) @Valid @RequestBody PatchShippingInstructionsRequest patchShippingInstructionsRequest,
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion
    ) {
        return getDelegate().patchShippingInstructions(documentReference, patchShippingInstructionsRequest, apIVersion);
    }


    /**
     * POST /v3/shipping-instructions-notifications : Send a new Shipping Instructions Notification
     * Creates a new [&#x60;Shipping Instructions Notification&#x60;](#/ShippingInstructionsNotification). This endPoint is called whenever a &#x60;Shipping Instructions&#x60; that a consumer has subscribed to changes state or is updated.  **This endPoint is to be implemented by a consumer of the EBL API in order to receive Notifications** 
     *
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @param shippingInstructionsNotification The payload used to create a [&#x60;Shipping Instructions Notification&#x60;](#/ShippingInstructionsNotification)  (optional)
     * @return No Content  (status code 204)
     *         or In case the &#x60;Notification&#x60; does not schema validate a &#x60;400&#x60; (Bad Request) is returned  (status code 400)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "shippingInstructionsNotifications",
        summary = "Send a new Shipping Instructions Notification",
        description = "Creates a new [`Shipping Instructions Notification`](#/ShippingInstructionsNotification). This endPoint is called whenever a `Shipping Instructions` that a consumer has subscribed to changes state or is updated.  **This endPoint is to be implemented by a consumer of the EBL API in order to receive Notifications** ",
        tags = { "Notifications" },
        responses = {
            @ApiResponse(responseCode = "204", description = "No Content "),
            @ApiResponse(responseCode = "400", description = "In case the `Notification` does not schema validate a `400` (Bad Request) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v3/shipping-instructions-notifications",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<Void> shippingInstructionsNotifications(
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion,
        @Parameter(name = "ShippingInstructionsNotification", description = "The payload used to create a [`Shipping Instructions Notification`](#/ShippingInstructionsNotification) ") @Valid @RequestBody(required = false) ShippingInstructionsNotification shippingInstructionsNotification
    ) {
        return getDelegate().shippingInstructionsNotifications(apIVersion, shippingInstructionsNotification);
    }


    /**
     * POST /v3/transport-document-notifications : Send a new Transport Document Notification
     * Creates a new [&#x60;Transport Document Notification&#x60;](#/TransportDocumentNotification). This endPoint is called whenever a &#x60;Transport Document&#x60; that a cosumer has subscribed to changes state or is updated.  **This endPoint is to be implemented by a consumer of the EBL API in order to receive Notifications** 
     *
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @param transportDocumentNotification The payload used to create a [&#x60;Transport Document Notification&#x60;](#/TransportDocumentNotification)  (optional)
     * @return No Content  (status code 204)
     *         or In case the &#x60;Notification&#x60; does not schema validate a &#x60;400&#x60; (Bad Request) is returned  (status code 400)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "transportDocumentNotifications",
        summary = "Send a new Transport Document Notification",
        description = "Creates a new [`Transport Document Notification`](#/TransportDocumentNotification). This endPoint is called whenever a `Transport Document` that a cosumer has subscribed to changes state or is updated.  **This endPoint is to be implemented by a consumer of the EBL API in order to receive Notifications** ",
        tags = { "Notifications" },
        responses = {
            @ApiResponse(responseCode = "204", description = "No Content "),
            @ApiResponse(responseCode = "400", description = "In case the `Notification` does not schema validate a `400` (Bad Request) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/v3/transport-document-notifications",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<Void> transportDocumentNotifications(
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion,
        @Parameter(name = "TransportDocumentNotification", description = "The payload used to create a [`Transport Document Notification`](#/TransportDocumentNotification) ") @Valid @RequestBody(required = false) TransportDocumentNotification transportDocumentNotification
    ) {
        return getDelegate().transportDocumentNotifications(apIVersion, transportDocumentNotification);
    }


    /**
     * PUT /v3/shipping-instructions/{documentReference} : Updates the Shipping Instructions 
     * Updates the &#x60;Shipping Instructions&#x60; with the &#x60;documentReference&#x60;. The path can contain either a &#x60;shippingInstructionsReference&#x60; or a &#x60;transportDocumentReference&#x60;. This endPoint corresponds with **UseCase 3 - Submit updated Shipping Instructions**  ### Precondition In order to update a &#x60;Shipping Instructions&#x60;, the status of the &#x60;Shipping Instructions&#x60; needs to be in state:  - &#x60;RECEIVED&#x60; in case the consumer has updated information for the &#x60;Shipping Instructions&#x60; - &#x60;PENDING_UPDATE&#x60; in case the provider has requested the consumer to update the &#x60;Shipping Instructions&#x60; (a result of **UseCase 2 - Request to update Shipping Instructions**)  ## Postcondition The provider has received an update to the &#x60;Shipping Instructions&#x60; (**UseCase 3 - Submit updated Shipping Instructions**), from now on called the &#x60;Updated Shipping Instructions&#x60;.  The &#x60;Updated Shipping Instructions&#x60; and the \&quot;original\&quot; &#x60;Shipping Instructions&#x60; **co-exist** until a new update is submitted by the consumer (via **UseCase 3: Submit updated Shipping Instructions**) or until the provider requests an update (sets the &#x60;shippingInstructionsStatus&#x3D;&#39;PENDING_UPDATE&#39;&#x60; via **UseCase 2: Request to update Shipping Instructions**). The &#x60;Updated Shipping Instructions&#x60; always represents the latest version of an update received by the provider.  The consumer will receive a &#x60;202&#x60; (Accepted) if the payload schema-validates or a &#x60;400&#x60; (Bad Request) if it does not.  ## Flow for the &#x60;202&#x60; (Accepted) response The following occurs when a provider receives an **update** to a &#x60;Shipping Instructions&#x60; 1. The payload (&#x60;Updated Shipping Instructions&#x60;) is schema-validated. In case the payload **is invalid** a &#x60;400&#x60; (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided     - all values provided have correct data type. 3. An empty response is returned and the consumer now awaits further processing by the provider.  For &#x60;PUT&#x60; &#x60;Shipping Instructions&#x60; the process ends here. The &#x60;Shipping Instructions&#x60;:   - is now accepted by the provider system   - the status of the &#x60;Shipping Instructions&#x60; is unchanged   - a &#x60;202&#x60; (Accepted) response is sent with an empty payload   - awaits further processing by the provider  The provider will now start asynchronous processing. Once processed, the state will change to one of the following values depending on the use case for calling the &#x60;PUT&#x60; endPoint:   - &#x60;shippingInstructionsStatus&#x3D;&#39;RECEIVED&#39;&#x60; and &#x60;updatedShippingInstructionsStatus&#x3D;&#39;UPDATE_RECEIVED&#39;&#x60; (if endPoint is used to make an update to a Submitted Shipping Instructions - **UseCase 1 - Submit Shipping Instructions**)   - &#x60;shippingInstructionsStatus&#x3D;&#39;PENDING_UPDATE&#39;&#x60; and &#x60;updatedShippingInstructionsStatus&#x3D;&#39;UPDATE_RECEIVED&#39;&#x60; (if endPoint is used as a response to **UseCase 2 - Request to update Shipping Instructions**)  The new state will be communicated via a [Shipping Instructions Notification](#/ShippingInstructionsNotification). In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/shipping-instructions/{documentReference}      endPoint to check if the &#x60;shippingInstructionsStatus&#x60; and &#x60;updatedShippingInstructionsStatus&#x60; of the &#x60;Shipping Instructions&#x60; has changed.    If the consumer wants to get the content of the &#x60;Update Shipping Instructions&#x60; provided via this &#x60;PUT&#x60; endPoint,  the &#x60;GET&#x60; endPoint needs to be used in combination with the &#x60;?updatedContent&#x3D;true&#x60; queryParameter:        GET /v3/shipping-instructions/{documentReference}?updatedContent&#x3D;true      It is possible to &#x60;GET&#x60; the content of the &#x60;Updated Shipping Instructions&#x60; via the example above until either:   - the provider requests for a new update (**UseCase 2: Request to update Shipping Instructions**) in which case the \&quot;old update\&quot; is no longer accessible   - the consumer submits a new update (**UseCase 3: Submit updated Shipping Instructions**) in which case the \&quot;new update\&quot; provided **replaces** the \&quot;old update\&quot;. 
     *
     * @param documentReference An identifier for a &#x60;Shipping Instructions&#x60;. It can either be a &#x60;shippingInstructionsReference&#x60; or a &#x60;transportDocumentReference&#x60;.  (required)
     * @param updateShippingInstructions Parameters used to update the &#x60;Shipping Instructions&#x60;  (required)
     * @param apIVersion An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version.  (optional)
     * @return The &#x60;Shipping Instructions&#x60; update has been successfully accepted by the provider. &#x60;shippingInstructionsStatus&#x60; does not change, &#x60;updatedShippingInstructionsStatus&#x60; is not set and response payload is empty. Further processing will be done by provider.  (status code 202)
     *         or In case the updated &#x60;Shipping Instructions&#x60; does not schema validate a &#x60;400&#x60; (Bad Request) is returned  (status code 400)
     *         or In case the provider does not know about the &#x60;documentReference&#x60; used in the request (this could be because of a &#x60;POST&#x60; request that has not finished processing or simply because the resource does not exist) - it is possible for the provider to reject the requests by returning a &#x60;404&#x60; (Not Found)  (status code 404)
     *         or In case the provider is already processing the &#x60;Shipping Instructions&#x60; matching &#x60;shippingInstructionsReference&#x3D;&#39;si-123&#39;&#x60; or for any other reason cannot process the request, it is possible to reject the &#x60;PUT&#x60; request with a &#x60;409&#x60; (Conflict) response  (status code 409)
     *         or In case a server error occurs in provider system a &#x60;500&#x60; (Internal Server Error) is returned  (status code 500)
     *         or For other errors the error object should be populated with relevant information  (status code 200)
     */
    @Operation(
        operationId = "updateShippingInstructions",
        summary = "Updates the Shipping Instructions ",
        description = "Updates the `Shipping Instructions` with the `documentReference`. The path can contain either a `shippingInstructionsReference` or a `transportDocumentReference`. This endPoint corresponds with **UseCase 3 - Submit updated Shipping Instructions**  ### Precondition In order to update a `Shipping Instructions`, the status of the `Shipping Instructions` needs to be in state:  - `RECEIVED` in case the consumer has updated information for the `Shipping Instructions` - `PENDING_UPDATE` in case the provider has requested the consumer to update the `Shipping Instructions` (a result of **UseCase 2 - Request to update Shipping Instructions**)  ## Postcondition The provider has received an update to the `Shipping Instructions` (**UseCase 3 - Submit updated Shipping Instructions**), from now on called the `Updated Shipping Instructions`.  The `Updated Shipping Instructions` and the \"original\" `Shipping Instructions` **co-exist** until a new update is submitted by the consumer (via **UseCase 3: Submit updated Shipping Instructions**) or until the provider requests an update (sets the `shippingInstructionsStatus='PENDING_UPDATE'` via **UseCase 2: Request to update Shipping Instructions**). The `Updated Shipping Instructions` always represents the latest version of an update received by the provider.  The consumer will receive a `202` (Accepted) if the payload schema-validates or a `400` (Bad Request) if it does not.  ## Flow for the `202` (Accepted) response The following occurs when a provider receives an **update** to a `Shipping Instructions` 1. The payload (`Updated Shipping Instructions`) is schema-validated. In case the payload **is invalid** a `400` (Bad Request) is returned.     **The process stops here!** 2. The payload is schema-valid which means:     - all required properties are provided     - all values provided have correct data type. 3. An empty response is returned and the consumer now awaits further processing by the provider.  For `PUT` `Shipping Instructions` the process ends here. The `Shipping Instructions`:   - is now accepted by the provider system   - the status of the `Shipping Instructions` is unchanged   - a `202` (Accepted) response is sent with an empty payload   - awaits further processing by the provider  The provider will now start asynchronous processing. Once processed, the state will change to one of the following values depending on the use case for calling the `PUT` endPoint:   - `shippingInstructionsStatus='RECEIVED'` and `updatedShippingInstructionsStatus='UPDATE_RECEIVED'` (if endPoint is used to make an update to a Submitted Shipping Instructions - **UseCase 1 - Submit Shipping Instructions**)   - `shippingInstructionsStatus='PENDING_UPDATE'` and `updatedShippingInstructionsStatus='UPDATE_RECEIVED'` (if endPoint is used as a response to **UseCase 2 - Request to update Shipping Instructions**)  The new state will be communicated via a [Shipping Instructions Notification](#/ShippingInstructionsNotification). In case the consumer does not subscribe to notifications it is necessary for the consumer to poll on the      GET /v3/shipping-instructions/{documentReference}      endPoint to check if the `shippingInstructionsStatus` and `updatedShippingInstructionsStatus` of the `Shipping Instructions` has changed.    If the consumer wants to get the content of the `Update Shipping Instructions` provided via this `PUT` endPoint,  the `GET` endPoint needs to be used in combination with the `?updatedContent=true` queryParameter:        GET /v3/shipping-instructions/{documentReference}?updatedContent=true      It is possible to `GET` the content of the `Updated Shipping Instructions` via the example above until either:   - the provider requests for a new update (**UseCase 2: Request to update Shipping Instructions**) in which case the \"old update\" is no longer accessible   - the consumer submits a new update (**UseCase 3: Submit updated Shipping Instructions**) in which case the \"new update\" provided **replaces** the \"old update\". ",
        tags = { "Shipping Instructions" },
        responses = {
            @ApiResponse(responseCode = "202", description = "The `Shipping Instructions` update has been successfully accepted by the provider. `shippingInstructionsStatus` does not change, `updatedShippingInstructionsStatus` is not set and response payload is empty. Further processing will be done by provider. "),
            @ApiResponse(responseCode = "400", description = "In case the updated `Shipping Instructions` does not schema validate a `400` (Bad Request) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "404", description = "In case the provider does not know about the `documentReference` used in the request (this could be because of a `POST` request that has not finished processing or simply because the resource does not exist) - it is possible for the provider to reject the requests by returning a `404` (Not Found) ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "409", description = "In case the provider is already processing the `Shipping Instructions` matching `shippingInstructionsReference='si-123'` or for any other reason cannot process the request, it is possible to reject the `PUT` request with a `409` (Conflict) response ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "500", description = "In case a server error occurs in provider system a `500` (Internal Server Error) is returned ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            }),
            @ApiResponse(responseCode = "default", description = "For other errors the error object should be populated with relevant information ", content = {
                @Content(mediaType = "application/json", schema = @Schema(implementation = ErrorResponse.class))
            })
        }
    )
    @RequestMapping(
        method = RequestMethod.PUT,
        value = "/v3/shipping-instructions/{documentReference}",
        produces = { "application/json" },
        consumes = { "application/json" }
    )
    
    default ResponseEntity<Void> updateShippingInstructions(
        @Pattern(regexp = "^\\S(?:.*\\S)?$") @Size(max = 100) @Parameter(name = "documentReference", description = "An identifier for a `Shipping Instructions`. It can either be a `shippingInstructionsReference` or a `transportDocumentReference`. ", required = true, in = ParameterIn.PATH) @PathVariable("documentReference") String documentReference,
        @Parameter(name = "UpdateShippingInstructions", description = "Parameters used to update the `Shipping Instructions` ", required = true) @Valid @RequestBody UpdateShippingInstructions updateShippingInstructions,
        @Parameter(name = "API-Version", description = "An API-Version header **MAY** be added to the request (optional); if added it **MUST** only contain **MAJOR** version. API-Version header **MUST** be aligned with the URI version. ", in = ParameterIn.HEADER) @RequestHeader(value = "API-Version", required = false) String apIVersion
    ) {
        return getDelegate().updateShippingInstructions(documentReference, updateShippingInstructions, apIVersion);
    }

}
